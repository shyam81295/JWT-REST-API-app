package controller

import (
	"api_backend_app/model"
	userRepository "api_backend_app/repository/user"
	"api_backend_app/utils"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/dgrijalva/jwt-go"
	"golang.org/x/crypto/bcrypt"
)

type Controller struct {
}

// Register : Handler for "/register" endpoint.
func (c Controller) Register(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Println("Register Handler Invoked")
		var user model.User
		var error model.Error
		// Decoder reads and decodes JSON from input stream.
		// Decode stores JSON values in the value pointed to by the interface (here User struct).
		json.NewDecoder(r.Body).Decode(&user)

		// validate email
		if user.Email == "" {
			// respond with "Bad Request" status error.
			error.Message = "Email ID cannot be empty."
			utils.RespondWithError(w, http.StatusBadRequest, error)
			return
		}

		// validate password
		if user.Password == "" {
			// respond with "Bad Request" status error.
			error.Message = "Password cannot be empty."
			utils.RespondWithError(w, http.StatusBadRequest, error)
			return
		}

		// Hash the password using bcrypt library, returns hashed password in slice of bytes.
		hash, err := bcrypt.GenerateFromPassword([]byte(user.Password), 10)
		if err != nil {
			log.Fatal(err)
		}

		// Convert a slice of bytes to string
		user.Password = string(hash)

		// Push User Email & it's hashed Password to DB, also get the ID generated by DB.
		userRepo := userRepository.UserRepository{}
		user, err = userRepo.Register(db, user)

		// If error from DB, then give out Internal Server error.
		if err != nil {
			error.Message = "Server Error."
			utils.RespondWithError(w, http.StatusInternalServerError, error)
			return
		}

		// For response, we can't send hashed password back.
		user.Password = ""

		// Write the Response back with User's ID & Email and blank password.
		w.Header().Set("Content-Type", "application/json")
		utils.ResponseJSON(w, user)
	}
}

// Login : Handler for "/login" endpoint.
func (c Controller) Login(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Println("Login Handler Invoked")
		var user model.User
		var jwt model.JWT
		var error model.Error

		// Decode the User's request
		json.NewDecoder(r.Body).Decode(&user)

		// Validate Email
		if user.Email == "" {
			error.Message = "Email cannot be empty."
			utils.RespondWithError(w, http.StatusBadRequest, error)
			return
		}

		// validate Password
		if user.Password == "" {
			error.Message = "Password cannot be empty."
			utils.RespondWithError(w, http.StatusBadRequest, error)
			return
		}

		passwordGiven := user.Password

		// Get User's ID, Email & hashed Password to DB.
		userRepo := userRepository.UserRepository{}
		user, err := userRepo.Login(db, user)

		if err != nil {
			if err != sql.ErrNoRows {
				log.Fatal(err)
			} else {
				error.Message = "User does not exist"
				utils.RespondWithError(w, http.StatusBadRequest, error)
				return
			}
		}

		hashedPassword := user.Password

		isEqual := utils.ComparePasswords(hashedPassword, []byte(passwordGiven))
		if !isEqual {
			error.Message = "Invalid Password"
			utils.RespondWithError(w, http.StatusBadRequest, error)
			return
		}

		tokenString, err := utils.GenerateToken(user)
		if err != nil {
			log.Fatal(err)
		}

		// If we reach here, then it means User's credentials are correct
		// 	and Token has been generated to be given as response.
		w.WriteHeader(http.StatusOK)
		jwt.Token = tokenString
		utils.ResponseJSON(w, jwt)
	}
}

// TokenVerifyMiddleware : sits between API endpoint & its handler function. If token is valid, then only it provides handler fucntion.
func (c Controller) TokenVerifyMiddleware(next http.HandlerFunc) http.HandlerFunc {

	return func(w http.ResponseWriter, r *http.Request) {
		secret := os.Getenv("SECRET")
		var errorObj model.Error
		authHeader := r.Header.Get("Authorization")
		bearerToken := strings.Split(authHeader, " ")

		if len(bearerToken) == 2 {
			authToken := bearerToken[1]

			// Parse expects 'JWT token to be verified' should be passed.
			// Also it expects that we do both :
			// 		verify the algorithm of header and return the signing "secret' in the callback function of Parse.
			//		so that it can be verify authToken.
			// Parse() parses, validates & returns the parsed token
			token, err := jwt.Parse(authToken, func(token *jwt.Token) (interface{}, error) {
				if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
					return nil, fmt.Errorf("There was an Error")
				}

				return []byte(secret), nil
			})

			if err != nil {
				errorObj.Message = err.Error() // Giving out JWT's errors to message
				utils.RespondWithError(w, http.StatusUnauthorized, errorObj)
				return
			}

			// Serve next middleware or last handler
			if token.Valid {
				next.ServeHTTP(w, r)
			} else {
				errorObj.Message = err.Error() // Giving out JWT's errors to message
				utils.RespondWithError(w, http.StatusUnauthorized, errorObj)
				return
			}
		} else {
			errorObj.Message = "Invalid token"
			utils.RespondWithError(w, http.StatusBadRequest, errorObj)
			return
		}
	}
}
